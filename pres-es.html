<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<meta name="author" content="Miguel Haro Ruiz"/>

		<title>IBEX - RConf 2023</title>

		<!-- <link rel="stylesheet" href="dist/reset.css"> -->
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/simple.css">
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&family=Noto+Serif:wght@300;400;500;600&family=Open+Sans:wght@200;300;400;500;600&family=Inter:wght@300;400;500;600&family=Poppins:wght@300;400;500;600&family=Nunito+Sans:wght@300;400;500;600&family=Kanit:wght@200;300;400;500;600&family=Outfit:wght@100;200;300;400;500;600&family=Sometype+Mono:wght@400;500;600&display=swap" rel="stylesheet">	
		<!-- Theme used for syntax highlighted code -->
		<!-- <link rel="stylesheet" href="plugin/highlight/monokai.css"> -->
		<link rel="stylesheet" href="styles/style.css">
	</head>
	<body>

		<script src="js/d3.v7.min.js"></script>

		<div class="reveal">

			<div class="slides">

				<section>
					<h2 class="main-title">El impacto de la excepción ibérica sobre la inflación:</h2>
					<h4 class="main-subtitle">Estimación a través de controles sintéticos</h4>
					<p class="authors" id="first-author">
						Miguel 
						<span style="font-weight: 400;">
							Haro Ruiz
						</span>
					</p>
					<p class="authors">Christoph
						<span style="font-weight: 400;">
							Schult
						</span> 
					</p>
					<p class="authors">Christoph
						<span style="font-weight: 400;">
							Wunder
						</span>  
					</p>
					
				</section>

				<section>
					<p class="plot-title-1">
						<span class="gas-span">Precio medio de la electricidad</span>
						en la UE
						<select id="selectOption">
							<option class="selectedItem" value="before">Antes</option>
							<option class="selectedItem" value="during">Durante</option>
						</select>
						de la crisis energética
					</p>
					<div id="containerCTX"></div>
					<script src="js/d3.v7.min.js"></script>
					<script type="module">

						const rawElecGas = await d3.csv("data/elec_gas.csv");
						const s1_date = "2020-06-01"
						const e1_date = "2021-06-01"
						const s2_date = "2021-06-15"
						const e2_date = "2022-06-15"
						const elecGas = rawElecGas.filter((d) => Date.parse(d.date) >= Date.parse(s1_date) 
							& Date.parse(d.date) <= Date.parse(e2_date)
							);
						const gasOnly = elecGas.filter((d) => Date.parse(d.date) >= Date.parse(s2_date) 
							& Date.parse(d.date) <= Date.parse(e2_date) 
							& (parseFloat(d.gas) >= 0 | parseFloat(d.gas) <= 500 )
							);

						// Declare the chart dimensions and margins
						const widthCTX = 900, 
							heightCTX = 500, 
							marginTopCTX = 15, 
							marginRightCTX = 45, 
							marginBottomCTX = 50, 
							marginLeftCTX = 80;
						
						// Declare the positional encodings
						const xCTX = d3.scaleUtc()
					        .domain([Date.parse(s1_date), Date.parse(e1_date)])
						    .range([marginLeftCTX, widthCTX - marginRightCTX]);

						const yCTX = d3.scaleLinear()
						    .domain([0, 415])
						    .range([heightCTX - marginBottomCTX, marginTopCTX]);

						const elecLine = d3.line()
						    .curve(d3.curveLinear)
						    .x((d) => xCTX(Date.parse(d.date)))
						    .y((d) => yCTX(d.elec));

						const gasLine = d3.line()
						    .curve(d3.curveLinear)
						    .x((d) => xCTX(Date.parse(d.date)))
						    .y((d) => yCTX(d.gas));

						length = (path) => d3.create("svg:path").attr("d", path).node().getTotalLength();
						const lCTX = length(gasLine(gasOnly));

						const svgCTX = d3.create("svg")
						    .attr("width", widthCTX + marginLeftCTX + marginRightCTX)
						    .attr("height", heightCTX + marginTopCTX + marginBottomCTX);

						const gCTX = svgCTX.append("g")
						    .attr("transform", `translate(${marginLeftCTX}, ${marginTopCTX})`);

						gCTX.append("g")
							.attr("class", "movingAxis")
						    .attr("transform", `translate(0,${heightCTX - marginBottomCTX})`)
						    .call(d3.axisBottom(xCTX).ticks(widthCTX / 400))
						    .call(g => g.select(".domain").remove())
						    .call(g => g.selectAll(".tick line")
						        .attr("y2", -heightCTX)
						        .attr("stroke-opacity", 0.1))
						    .call(g => g.selectAll(".tick text")
						        .attr("font-size", "20px")
								.attr("font-family", "Poppins"))
						
						gCTX.append("g")
						    .append("path")
						    .datum(elecGas)
						    .style("fill", "none")
						    .style("stroke", "#a91ee1")
						    .style("stroke-width", 2.5)
							.attr("class", "movingLine")
						    .attr("stroke-linejoin", "round")
						    .attr("stroke-linecap", "round")
						    .attr("d", elecLine);
							
						d3.select("#selectOption").on("change", (event) => { 

							if (d3.select("#selectOption").node().value == "before") {

								xCTX.domain([Date.parse(s1_date), Date.parse(e1_date)]);

								gCTX.select(".movingAxis")
									.transition()
									.duration(3000)
									.call(d3.axisBottom(xCTX).ticks(widthCTX / 400))
									.call(g => g.select(".domain").remove())
									.call(g => g.selectAll(".tick line")
										.attr("y2", - heightCTX + marginTopCTX)
										.attr("stroke-opacity", 0.1))
									.call(g => g.selectAll(".tick text")
										.attr("font-size", "20px")
										.attr("font-family", "Poppins"));

								gCTX.select(".movingLine")
									.transition()
									.duration(3000)
									.attr("d", elecLine);

							} else if (d3.select("#selectOption").node().value == "during") {

								xCTX.domain([Date.parse(s2_date), Date.parse(e2_date)]);
							
								gCTX.select(".movingAxis")
									.transition()
									.duration(3000)
									.call(d3.axisBottom(xCTX).ticks(widthCTX / 400))
									.call(g => g.select(".domain").remove())
									.call(g => g.selectAll(".tick line")
										.attr("y2", - heightCTX + marginTopCTX)
										.attr("stroke-opacity", 0.1))
									.call(g => g.selectAll(".tick text")
										.attr("font-size", "20px")
										.attr("font-family", "Poppins"));
								
								gCTX.select(".movingLine")
									.transition()
									.duration(3000)
									.attr("d", elecLine);

							}
						})

						gCTX.append('rect')
  							.attr('fill', 'white')
							//.attr("stroke", "black")
  							.attr('width', marginLeftCTX * 2)
  							.attr('height', heightCTX)
							.attr('x', -marginLeftCTX)
							.attr('y', 0);

						gCTX.append("g")
    						.attr("transform", `translate(${marginLeftCTX/1.5},0)`)
    						.call(d3.axisLeft(yCTX).ticks(heightCTX/100))
    						.call(g => g.select(".domain").remove())
    						.call(g => g.selectAll(".tick line")
    						    .attr("x2", widthCTX)
    						    .attr("stroke-opacity", 0.1))
    						.call(g => g.selectAll(".tick text")
    						    .attr("font-size", "20px")
    						    .attr("font-family", "Poppins"));

						gCTX.append("text")
    						.attr("x", -300)
    						.attr("y", -35)
    						.attr("font-weight", "normal")
    						.text("Euros/MWh")
    						.attr("transform", "rotate(-90)")
    						.attr("font-size", "30px")
    						.attr("font-family", "Inter");
						
						gCTX.append('rect')
  							.attr('fill', 'white')
							//.attr("stroke", "black")
  							.attr('width', marginRightCTX*3)
  							.attr('height', heightCTX)
							.attr('x', widthCTX - marginRightCTX)
							.attr('y', 0);

						svgCTX.on("click", (event) => { 

							gCTX.append("path")
							    .datum(gasOnly)
							    .attr("fill", "none")
							    .attr("stroke", "#47ba19")
							    .attr("stroke-width", 2.5)
							    .attr("stroke-linejoin", "round")
							    .attr("stroke-linecap", "round")
							    .attr("stroke-dasharray", `0,${lCTX}`)
							    .attr("d", gasLine)
							    .transition()
							    //.delay(5000)
							    .duration(2500)
							    //.ease(d3.easeLinear)
							    .attr("stroke-dasharray", `${lCTX},${lCTX}`);

							gCTX.append("text")
								.text("Gas")
								.attr("x", xCTX(Date.parse(e2_date)) + 7.5)
								.attr("y", 345)
								.attr("font-family", "Kanit")
								.attr("font-size", "25px")
								.style("text-anchor", "start")
								.style("fill", "#47ba19")
								.style("opacity", 0)
							    .transition()
								.delay(1750)
								.duration(1000)
								.style("opacity", 1)

							gCTX.append("text")
								.text("Futuro")
								.attr("x", xCTX(Date.parse(e2_date)) + 7.5)
								.attr("y", 370)
								.attr("font-family", "Kanit")
								.attr("font-size", "25px")
								.style("text-anchor", "start")
								.style("fill", "#47ba19")
								.style("opacity", 0)
							    .transition()
								.delay(1750)
								.duration(1000)
								.style("opacity", 1)

							})
						
					    containerCTX.append(svgCTX.node());

					</script>

				</section>

				<section class="chapter" data-transition="slide" data-background-color="rgb(35, 35, 35)">
					<h1>La excepción ibérica</h1>
				</section>

				<section>
					<h2 class="slide-title-2">La IBEX</h2>
					<p class="fragment slide-text-2">Entra en vigor el 15 de Junio de 2023</p>
					<p class="fragment slide-text-2"><b>Desacopla</b> el precio de la electricidad del precio del gas:</p>
					<ol class="list-2">
						<li class="fragment">Fijar tope al precio de electricidad producida con gas</li>
						<li class="fragment">Mecanismo de ajuste para evitar posibles pérdidas</li>
						<li class="fragment">Pagado por consumidores + exportaciones a Francia</li>
					</ol>
				</section>

				<section>
					<h2 class="slide-title-2">La excepción de iberia</h2>
					<ul class="list-1">
						<p class="fragment slide-text-1" data-fragment-index="1">Estrategias contra la crisis energética en la UE:</p>
						<ul class="sublist-1">
							<li class="fragment" data-fragment-index="2">Reducciones fiscales</li>
							<li class="fragment" data-fragment-index="2">Transferencias directas</li>
							<li class="fragment" data-fragment-index="2">Regulación del mercado minorista</li>
						</ul>
						<p class="fragment slide-text-1" data-fragment-index="3">La IBEX es la 
							<span style="font-weight: 400;">única medida</span> 
							que interviene en el mercado mayorista
						</p>
					</ul>
				</section>

				<section>
					<h2 class="slide-title-2">Diseño experimental</h2>
					<ul class="list-1">
						<p class="slide-text-1 fragment" data-fragment-index="1">
							La IBEX presenta un 
							<span style="font-weight: 400;">experimento natural</span>
						</p>
						<ul class="sublist-1">
							<li class="fragment" data-fragment-index="1">mientras el mercado ibérico opera bajo nuevas normas;</li>
							<li class="fragment" data-fragment-index="2">Los otros mercados de la UE operan con normalidad</li>
						</ul>
						<p class="slide-text fragment" data-fragment-index="3">Objetivo de la inverstigación:</p>
						<ul class="sublist-1">
							<p class="fragment slide-text-2" data-fragment-index="3">Estimar el impacto causal de la IBEX sobre los precios</p>
						</ul>
					</ul>
				</section>

				<section class="chapter" data-transition="slide" data-background-color="rgb(35, 35, 35)">
					<h1>Metodología</h1>
				</section>

				<section>
					<h2 class="slide-title">Metodología</h2>
					<ul class="list-4">
						<p class="slide-text-1">Estimación contrafactual vía 
							<span style="font-weight: 400;">controles sintéticos</span>
						</p>
						<p class="fragment slide-text-1" data-fragment-index="1">Variables de interés</p>
						<ul class="sublist-4">
							<li class="fragment" data-fragment-index="1">
								<span style="font-weight: 400;">DAP:</span> 
								Precio diario de electricidad
							</li>
							<li class="fragment" data-fragment-index="2">
								<span style="font-weight: 400;">NRG:</span> 
								Índice de Precios de Consumo (IPC) de energía
							</li>
							<li class="fragment" data-fragment-index="3">
								<span style="font-weight: 400;">xNRG:</span>
								IPC excluyendo energía
								</li>
							<li class="fragment" data-fragment-index="4">
								<span style="font-weight: 400;">CP00:</span> 
								IPC general
							</li>
						</ul>
					</ul>
				</section>

				
				<section class="chapter" data-transition="slide" data-background-color="rgb(35, 35, 35)">
					<h1>Resultados</h1>
				</section>

				<section>
					<p class="plot-title-2">IPC general
						<span class="obs-span">Observable</span>
						y 
						<span class="synth-span">sintético</span>
						en España
					</p>
					<div id="containerSC"></div>
					<!-- <script src="js/d3.v7.min.js"></script> -->
					<script type="module">

						const rawSCSeries = await d3.csv("data/sc_series.csv");

						// Declare the chart dimensions and margins
						const widthSC = 900;
						const heightSC = 500;
						const marginTopSC = 30;
						const marginRightSC = 30;
						const marginBottomSC = 60;
						const marginLeftSC = 60;

						const interv_date = "2022-06-01";
						const start_date = "2013-01-01";
						const end_date = "2023-03-01";
						const SCSeries = rawSCSeries.filter((d) => d.treated == "ES" & d.outcome == "CP00");
						const preSeries = SCSeries.filter((d) => Date.parse(d.date) <= Date.parse(interv_date));
						const postSeries = SCSeries.filter((d) => Date.parse(d.date) >= Date.parse(interv_date));

						// Declare the positional encodings
						const xSC = d3.scaleUtc()
					        .domain([Date.parse(start_date), Date.parse(end_date)])
						    .range([marginLeftSC, widthSC - marginRightSC]);

						const ySC = d3.scaleLinear()
						    .domain([95, 125])
						    .range([heightSC - marginBottomSC, marginTopSC]);

						const svgSC = d3.create("svg")
						    .attr("width", widthSC + marginLeftSC + marginRightSC)
						    .attr("height", heightSC + marginTopSC + marginBottomSC);

						const gSC = svgSC.append("g")
						    .attr("transform", `translate(${marginLeftSC}, ${marginTopSC})`);

						const obsLine = d3.line()
						    .curve(d3.curveLinear)
						    .x((d) => xSC(Date.parse(d.date)))
						    .y((d) => ySC(d.obs));

						const synthLine = d3.line()
						    .curve(d3.curveLinear)
						    .x((d) => xSC(Date.parse(d.date)))
						    .y((d) => ySC(d.synth));

						length = (path) => d3.create("svg:path").attr("d", path).node().getTotalLength();
						const lSC = length(synthLine(SCSeries));

						gSC.append("g")
						    .attr("transform", `translate(0,${heightSC + marginTopSC})`)
						    .call(d3.axisBottom(xSC).ticks(widthSC / 200))
						    .call(g => g.select(".domain").remove())
						    .call(g => g.selectAll(".tick line")
								.attr("y1", -(marginTopSC + marginBottomSC))
						        .attr("y2", -(heightSC + marginTopSC))
						        .attr("stroke-opacity", 0.1))
						    .call(g => g.selectAll(".tick text")
								.attr("y", -marginBottomSC)
						        .attr("font-size", "20px")
								.attr("font-family", "Poppins"))

						gSC.append("g")
						    .attr("transform", `translate(${marginLeftSC},0)`)
						    .call(d3.axisLeft(ySC).ticks(heightSC/150))
						    .call(g => g.select(".domain").remove())
						    .call(g => g.selectAll(".tick line")
						        .attr("x2", widthSC)
						        .attr("stroke-opacity", 0.1))
						    .call(g => g.selectAll(".tick text")
						        .attr("font-size", "20px")
								.attr("font-family", "Poppins"))
						
						// gSC.append('rect')
  						// 	.attr('fill', 'white')
						// 	.attr("stroke", "black")
  						// 	.attr('width', widthSC + marginRightSC)
  						// 	.attr('height', 60)
						// 	.attr('x', -5)
						// 	.attr('y', -20);

						gSC.append("text")
							.attr("x", -350)
						    .attr("y", -10)
						    .text("CPI, 2015 = 100")
						    .attr("transform", "rotate(-90)")
						    .attr("font-size", "30px")
							.attr("font-family", "Inter");

						gSC.append("text")
							.attr("x", xSC(Date.parse(interv_date))-10)
							.attr("y", 30)
							.style("text-anchor", "end")
							.text("IBEX")
							.attr("font-size", "20px")
							.attr("font-family", "Nunito sans")
						
						gSC.append("text")
							.attr("x", xSC(Date.parse(interv_date))-10)
							.attr("y", 55)
							.style("text-anchor", "end")
							.text("comienza")
							.attr("font-size", "20px")
							.attr("font-family", "Nunito sans")

						gSC.append("line")
						    .attr('x1', xSC(Date.parse(interv_date)))
						    .attr('y1', 0 - marginTopSC/2)
						    .attr('x2', xSC(Date.parse(interv_date)))
						    .attr('y2', heightSC - marginBottomSC)
						    .style("fill", "none")
						    .style("stroke", "#000")
						    .style("stroke-dasharray","5,5")
						    .style("stroke-width", 1);

						gSC.append("g")
						    .append("path")
						    .datum(preSeries)
						    .style("fill", "none")
						    .style("stroke", "#cc594c")
						    .style("stroke-width", 2.5)
						    .attr("stroke-linejoin", "round")
						    .attr("stroke-linecap", "round")
						    .attr("d", obsLine);

						svgSC.on("mouseenter", (event) => {

							gSC.append("path")
							    .datum(preSeries)
							    .attr("fill", "none")
							    .attr("stroke", "#4c3cdc")
							    .attr("stroke-width", 2.5)
							    .attr("stroke-linejoin", "round")
							    .attr("stroke-linecap", "round")
							    .attr("stroke-dasharray", `0,${lSC}`)
							    .attr("d", synthLine)
							    .transition()
							    .duration(3000)
							    .ease(d3.easeLinear)
							    .attr("stroke-dasharray", `${lSC},${lSC}`); 

						})

						svgSC.on("click", (event) => {

							gSC.append("path")
							    .datum(postSeries)
							    .style("fill", "none")
							    .style("stroke", "#cc594c")
							    .style("stroke-width", 2.5)
							    .attr("stroke-linejoin", "round")
							    .attr("stroke-linecap", "round")
							    .attr("stroke-dasharray", `0,${lSC}`)
							    .attr("d", obsLine)
							    .transition()
							    //.delay(5000)
							    .duration(2500)
							    .ease(d3.easeLinear)
							    .attr("stroke-dasharray", `${lSC},${lSC}`);

							gSC.append("path")
							    .datum(postSeries)
							    .attr("fill", "none")
							    .attr("stroke", "#4c3cdc")
							    .attr("stroke-width", 2.5)
							    .attr("stroke-linejoin", "round")
							    .attr("stroke-linecap", "round")
							    .attr("stroke-dasharray", `0,${lSC}`)
							    .attr("d", synthLine)
							    .transition()
							    //.delay(5000)
							    .duration(2500)
							    .ease(d3.easeLinear)
							    .attr("stroke-dasharray", `${lSC},${lSC}`);

						});
					
					    containerSC.append(svgSC.node());

					</script>
				</section>

				<section>
					<p class="plot-title-2">IPC general
						<span class="obs-span">Observable</span>
						y 
						<span class="synth-span">sintético</span>
						en España
					</p>
						<img class = "img1" src="images/CP00_es.png">
				</section>

				<section>
					<p class="plot-title-3">
						Efecto Medio del Tratamiento:
						<span class="es-span">España</span>
						y
						<span class="pt-span">Portugal</span>
					</p>
					<div class="legend-box">

						<p class="plot-subtitle-3">Intervalos de confianza 90%</p>	

						<div class="checkbox-ate">
							<div>
						  		<input type="checkbox" class="checkbox" value="DAP" checked />
						  		<label class="check-label">DAP</label>
							</div>
							<div>
						  		<input type="checkbox" class="checkbox" value="NRG"/>
						  		<label class="check-label">NRG</label>
							</div>
							<div>
						  		<input type="checkbox" class="checkbox" value="xNRG"/>
						  		<label class="check-label">xNRG</label>
							</div>
							<div>
						  		<input type="checkbox" class="checkbox" value="CP00"/>
						  		<label class="check-label">CP00</label>
							</div>
						</div>
					
					</div>
					

					<div id="containerATT"></div>
					<!-- <script src="js/d3.v7.min.js"></script> -->
					<script type="module">

						// Import and filter data
						const rawResults = await d3.csv("data/results_1.csv"),
							resultsDAP = rawResults.filter((d) => d.outcome == "DAP"),
							resultsNRG = rawResults.filter((d) => d.outcome == "NRG"),
							resultsxNRG = rawResults.filter((d) => d.outcome == "xNRG"),
							resultsCP00 = rawResults.filter((d) => d.outcome != "CP00");

						// Declare the chart dimensions and margins
						const widthATT = 900;
						const heightATT = 400;
						const marginTopATT = 50;
						const marginRightATT = 30;
						const marginBottomATT = 60;
						const marginLeftATT = 70;

						// Declare the positional encodings
						const xATT = d3.scaleLinear()
					        .domain([-75, 50])
						    .range([marginLeftATT, widthATT - marginRightATT]);

						const yATT = d3.scalePoint()
						    .domain(["CP00", "xNRG", "NRG", "DAP"])
						    .range([heightATT - marginBottomATT, marginTopATT]);

						const svgATT = d3.create("svg")
						    .attr("width", widthATT + marginLeftATT + marginRightATT)
						    .attr("height", heightATT + marginTopATT + marginBottomATT);

						const gATT = svgATT.append("g")
						    .attr("transform", `translate(${marginLeftATT/2}, ${marginTopATT/2})`);

						const bands = d3.line()
						    .curve(d3.curveLinear)
						    .x((d) => xATT(d.value))
						    .y((d) => yATT(d.outcome));

						gATT.append("g")
						    .attr("transform", `translate(0,${heightATT})`)
						    .call(d3.axisBottom(xATT).ticks(widthATT / 227)
							.tickFormat(function(d) {
								return d + "%"
							}))
						    .call(g => g.select(".domain").remove())
						    .call(g => g.selectAll(".tick line")
						        .attr("y2", -heightATT)
						        .attr("stroke-opacity", 0.1))
						    .call(g => g.selectAll(".tick text")
						        .attr("font-size", "20px")
								.attr("font-family", "Poppins"))
							
						gATT.append("text")
							.attr("x", marginLeftATT + widthATT/2.25)
							.attr("y", marginTopATT + heightATT + marginBottomATT/2)
							//.style("text-anchor", "end")
							.text("EMT")
							.attr("font-size", "30px")
							.attr("font-family", "Inter")

						gATT.append("g")
						    .attr("transform", `translate(${marginLeftATT}, 0)`)
						    .call(d3.axisLeft(yATT))
						    .call(g => g.select(".domain").remove())
						    .call(g => g.selectAll(".tick line")
						         .attr("x2", widthATT)
						         .attr("stroke-opacity", 0))
						     .call(g => g.selectAll(".tick text")
						         .attr("font-size", "20px")
							 	.attr("font-family", "Poppins"));

						gATT.append("line")
						    .attr('x1', xATT(0))
						    .attr('y1', -10)
						    .attr('x2', xATT(0))
						    .attr('y2', heightATT )
						    .style("fill", "none")
						    .style("stroke", "#000")
						    .style("stroke-width", 1);

						var colorATT = d3.scaleOrdinal()
							.domain("ES", "PT")
							.range(["#d11e1e", "#30a956"]);

						function jitter(x) {
							if (x == "ES") {
								return -15
							} else {
								return 15 
							}
						}

						gATT.selectAll("circle")
							.data(rawResults)
							.join("circle")
								.attr("class", d => `circ-${d.outcome}`)
								.attr("cx", d => xATT(d.pct_att))
								.attr("cy", d => yATT(d.outcome) + jitter(d.treated))
								.style("fill", (d) => colorATT(d.treated))
								.attr("r", 6)
								.style("opacity", 0)
								
						gATT.selectAll("confInts")
							.data(rawResults)
							.enter()
							.append("line")
								.attr("class", d => `line-${d.outcome}`)
						  		.attr("x1", (d) => xATT(d.pct_att))
						  		.attr("x2", (d) => xATT(d.pct_att))
						  		.attr("y1", (d) => yATT(d.outcome) + jitter(d.treated))
						  		.attr("y2", (d) => yATT(d.outcome) + jitter(d.treated))
						  		.attr("stroke", (d) => colorATT(d.treated))
								.attr("stroke-width", 2.5)
								.style("opacity", 0)

						gATT.selectAll("finness1")
							.data(rawResults)
							.enter()
							.append("line")
								.attr("class", d => `finn1-${d.outcome}`)
						  		.attr("x1", (d) => xATT(d.pct_lb))
						  		.attr("x2", (d) => xATT(d.pct_lb))
						  		.attr("y1", (d) => yATT(d.outcome) + jitter(d.treated)+ 5)
						  		.attr("y2", (d) => yATT(d.outcome) + jitter(d.treated) - 5)
						  		.attr("stroke", (d) => colorATT(d.treated))
								.attr("stroke-width", 2.5)
								.style("opacity", 0)
						
						gATT.selectAll("finness2")
							.data(rawResults)
							.enter()
							.append("line")
								.attr("class", d => `finn2-${d.outcome}`)
						  		.attr("x1", (d) => xATT(d.pct_ub))
						  		.attr("x2", (d) => xATT(d.pct_ub))
						  		.attr("y1", (d) => yATT(d.outcome) + jitter(d.treated)+ 5)
						  		.attr("y2", (d) => yATT(d.outcome) + jitter(d.treated) - 5)
						  		.attr("stroke", (d) => colorATT(d.treated))
								.attr("stroke-width", 2.5)
								.style("opacity", 0)

						function update() {

							d3.selectAll(".checkbox").each(function(d){
								const cb = d3.select(this),
									grp = cb.property("value");

								if(cb.property("checked")){

									gATT.selectAll(".circ-"+grp)
										.transition()
										.duration(500)
											.style("opacity", 1);

									gATT.selectAll(".line-"+grp)
										.transition()
										.duration(750)
						  					.attr("x1", (d) => xATT(d.pct_lb))
						  					.attr("x2", (d) => xATT(d.pct_ub))
											.style("opacity", 1);

									gATT.selectAll(".finn1-"+grp)
										.transition()
										.delay(650)
										.duration(50)
											.style("opacity", 1);
									
									gATT.selectAll(".finn2-"+grp)
										.transition()
										.delay(675)
										.duration(50)
											.style("opacity", 1);

								} else {

									gATT.selectAll(".circ-"+grp)
										.transition()
										.duration(500)
											.style("opacity", 0);

									gATT.selectAll(".line-"+grp)
										.transition()
										.duration(750)
						  					.attr("x1", (d) => xATT(d.pct_att))
						  					.attr("x2", (d) => xATT(d.pct_att))
											.style("opacity", 0);
									
									gATT.selectAll(".finn1-"+grp)
										.transition()
										.duration(50)
											.style("opacity", 0);
									
									gATT.selectAll(".finn2-"+grp)
										.transition()
										.duration(50)
											.style("opacity", 0);

								}
							})
						}

						d3.selectAll(".checkbox").on("change", update);
						
						update();

					    containerATT.append(svgATT.node());

					</script>
				</section>

				<!-- <section>
					<div class="r-stack">
						<img src="images/allResults1.png" width="926" height="550">
						<img class="fragment" src="images/allResults2.png" width="926" height="550">
					  </div>
				</section> -->

				<section class="chapter" data-transition="slide" data-background-color="rgb(35, 35, 35)">
					<h1>Análisis</h1>
				</section>

				<section>
					<h2 class="slide-title-3">¿Cómo se explica esta diferencia?</h2>
					<ul class="list-4">
						<p class="fragment slide-text" data-fragment-index="1">España</p>
						<ul class="sublist-4">
							<li class="fragment" data-fragment-index="1">Tarifa PVPC indexada por el precio mayorista</li>
							<li class="fragment" data-fragment-index="1">~40% de hogares y empresas</li>
							<li class="fragment"data-fragment-index="2">
								<span style="font-weight: 400;">Vínculo directo</span> 
								entre DAP y NRG
							</li>
						</ul>
						<p class="fragment slide-text" data-fragment-index="3">Portugal</p>
						<ul class="sublist-4" data-fragment-index="3">
							<li class="fragment" data-fragment-index="3">Distribuidores prefieren contratos a largo plazo</li>
							<li class="fragment" data-fragment-index="4">
								<span style="font-weight: 400;">Vínculo más lento</span> 
								entre DAP y NRG
							</li>
						</ul>
					</ul>
				</section>

				<section>
					<h2 class="slide-title-3">La IBEX es responsable de...</h2>
						<ul class="list-1">
							<p class="fragment slide-text-1" data-fragment-index="1"> -40% sobre el precio mayorista de electricidad</p>
							<p class="fragment slide-text-1" data-fragment-index="2">
								<span style="font-weight: 400;">
								España: impacto imediato y fuerte sobre IPC
							</span> 
							</p>
							<ul class="sublist-1">
								<li class="fragment" data-fragment-index="2"> -19 p.p. sobre IPC energético</li>
								<li class="fragment" data-fragment-index="2"> -3.5 p.p. sobre IPC general</li>
							</ul>
							<p class="fragment slide-text-1" data-fragment-index="3">
								<span style="font-weight: 400;">
									Portugal: impacto con 6 meses de retraso
								</span>
								
							</p>
							<ul class="sublist-1">
								<li class="fragment" data-fragment-index="3"> -12 p.p. sobre IPC energético en 2023</li>
								<li class="fragment" data-fragment-index="3">Sin impacto sobre IPC general</li>
							</ul>
						</ul>
				</section>

				<section>
					<p class="plot-title-1">
						Tasa de inflación energética en 
						<span class="es-span">Expaña</span>
						y
						<span class="pt-span">Portugal</span>
					</p>
					<div id="containerNRG"></div>
					<!-- <script src="js/d3.v7.min.js"></script> -->
					<script type="module">

						// Define date constants
						const startNRG = "2019-06-01";
						const intervNRG = "2022-06-15";
						const endNRG = "2023-09-01";

						// Import and filter data
						const rawInfl = await d3.csv("data/inflation.csv");
						const infl = rawInfl
						.filter(
							(d) => Date.parse(d.date) >= Date.parse(startNRG)
							& Date.parse(d.date) <= Date.parse(endNRG)
							);
						
						// Declare the chart dimensions and margins
						const widthNRG = 900;
						const heightNRG = 500;
						const marginTopNRG = 30;
						const marginRightNRG = 30;
						const marginBottomNRG = 30;
						const marginLeftNRG = 40;

						// Declare the positional encodings
						const xNRG = d3.scaleUtc()
					        .domain([Date.parse(startNRG), Date.parse(endNRG)])
						    .range([marginLeftNRG, widthNRG - marginRightNRG]);

						const yNRG = d3.scaleLinear()
						    .domain([-25, 65])
						    .range([heightNRG - marginBottomNRG, marginTopNRG]);

						const svgNRG = d3.create("svg")
						    .attr("width", widthNRG + marginLeftNRG + marginRightNRG)
						    .attr("height", heightNRG + marginTopNRG + marginBottomNRG);

						const gNRG = svgNRG.append("g")
						    .attr("transform", `translate(${marginLeftNRG}, ${marginTopNRG})`);

						const esLine = d3.line()
						    .curve(d3.curveLinear)
						    .x((d) => xNRG(Date.parse(d.date)))
						    .y((d) => yNRG(d.ES_NRG));

						const ptLine = d3.line()
						    .curve(d3.curveLinear)
						    .x((d) => xNRG(Date.parse(d.date)))
						    .y((d) => yNRG(d.PT_NRG));

						gNRG.append("g")
						    .attr("transform", `translate(0,${heightNRG - marginBottomNRG/2})`)
						    .call(d3.axisBottom(xNRG).ticks(widthNRG / 200))
						    .call(g => g.select(".domain").remove())
						    .call(g => g.selectAll(".tick line")
						        .attr("y2", -heightNRG)
						        .attr("stroke-opacity", 0.1))
						    .call(g => g.selectAll(".tick text")
						        .attr("font-size", "20px")
								.attr("font-family", "Poppins"))

						gNRG.append("g")
						    .attr("transform", `translate(${marginLeftNRG/2},0)`)
						    .call(d3.axisLeft(yNRG).ticks(heightNRG/100)
							.tickFormat(function(d) {
								return d + "%"
							}))
						    .call(g => g.select(".domain").remove())
						    .call(g => g.selectAll(".tick line")
						        .attr("x2", widthNRG)
						        .attr("stroke-opacity", 0.1))
						    .call(g => g.selectAll(".tick text")
						        .attr("font-size", "20px")
								.attr("font-family", "Poppins"))
						    // .call(g => g.select(".tick:last-of-type text")
						    //     .attr("x", -heightNRG/15)
						    //     .attr("y", -90)
						    //     .attr("font-weight", "normal")
						    //     .text("CPI, 2015 = 100")
						    //     .attr("transform", "rotate(-90)")
						    //     .attr("font-size", "30px")
							// 	.attr("font-family", "Inter"));

						gNRG.append("text")
							.attr("x", xNRG(Date.parse(intervNRG))-10)
							.attr("y", 400)
							.style("text-anchor", "end")
							.text("Intervention")
							.attr("font-size", "20px")
							.attr("font-family", "Nunito sans")
						
						gNRG.append("text")
							.attr("x", xNRG(Date.parse(intervNRG))-10)
							.attr("y", 425)
							.style("text-anchor", "end")
							.text("begins")
							.attr("font-size", "20px")
							.attr("font-family", "Nunito sans")

						gNRG.append("line")
						    .attr('x1', xNRG(Date.parse(intervNRG)))
						    .attr('y1', 0)
						    .attr('x2', xNRG(Date.parse(intervNRG)))
						    .attr('y2', heightNRG)
						    .style("fill", "none")
						    .style("stroke", "#000")
						    .style("stroke-dasharray","5,5")
						    .style("stroke-width", 1);

						gNRG.append("line")
						    .attr('x1', marginLeftNRG)
						    .attr('y1', yNRG(0))
						    .attr('x2', widthNRG)
						    .attr('y2', yNRG(0))
						    .style("fill", "none")
						    .style("stroke", "#000")
						    .style("stroke-width", 1);

						gNRG.append('rect')
  							.attr('fill', 'white')
							//.attr("stroke", "black")
  							.attr('width', marginRightNRG * 3)
  							.attr('height', heightNRG)
							.attr('x', widthNRG - marginRightNRG)
							.attr('y', 0);

						length = (path) => d3.create("svg:path").attr("d", path).node().getTotalLength();
						const lNRG = length(esLine(infl));

						gNRG.on("click", (event) => {
							
						})

						var colorNRG = d3.scaleOrdinal()
							.domain("ES", "PT")
							.range(["#d11e1e", "#30a956"])

						gNRG.append("g")
						    .append("path")
						    .datum(infl)
						    .style("fill", "none")
						    .style("stroke", "#d11e1e")
						    .style("stroke-width", 2.5)
						    .attr("stroke-linejoin", "round")
						    .attr("stroke-linecap", "round")
						    .attr("d", esLine);

						gNRG.append("g")
						    .append("path")
						    .datum(infl)
						    .style("fill", "none")
						    .style("stroke", "#30a956")
						    .style("stroke-width", 2.5)
						    .attr("stroke-linejoin", "round")
						    .attr("stroke-linecap", "round")
						    .attr("d", ptLine);

					    containerNRG.append(svgNRG.node());

					</script>
				</section>

				<section>
					<h2 class="slide-title-4">
						La IBEX: una 
						<span style="font-weight: 400;">medida efectiva</span> 
						que destaca las
						<span style="font-weight: 400;">limitaciones del PVPC</span>
					</h2>

					<div class="fragment fade-left bss-card">
						<p class="bss-name">Miguel <span style="font-weight: 300;">Haro Ruiz</span></p>
						<p class="bss-mail">m.haroruiz@gmail.com</p>
						<p class="bss-web">theprior.xyz</p>
					</div>
				</section>

				<section>
					<h2 class="slide-title">References</h2>
					<ul class="references">
						<li>Abadie, A., 2021. Using synthetic controls: Feasibility, data requirements, and methodological aspects. Journal of Economic Literature 59, 391–425. doi:10.1257/jel.20191450.</li>
						<li>Abadie, A., Diamond, A., Hainmueller, J., 2010. Synthetic control methods for comparative case studies: Estimating the effect of California’s tobacco control program. Journal of the American Statistical Association 105, 493–505. doi:10.1198/jasa.2009.ap08746.</li>
						<li>Abadie, A., Gardeazabal, J., 2003. The economic costs of conflict: A case study of the Basque Country. American Economic Review 93, 113–132. doi:10.1257/000282803321455188.</li>
						<li>Barsky, R.B., Kilian, L., 2002. Oil and the macroeconomy since the 1970s. Journal of Economic Perspectives 18, 115–134. doi:10.3386/w10855.</li>
						<li></li>
					</ul>
				</section>

				<section>
					<h2 class=" slide-title">References</h2>
					<ul class="references">
						<li>Chernozhukov, V., Wuthrich, K., Zhu, Y., 2022. Practical and robust t-test based inference for synthetic control and related methods. arxiv e-prints. arXiv preprint arXiv:1812.10820v4</li>
						<li>Clark, T.E., Terry, S.J., 2010. Time variation in the inflation passthrough of energy prices. Journal of Money, Credit and Banking 42, 1419–1433. doi:10.2139/ssrn.1349851.</li>
						<li>Ferman, B., Pinto, C., Possebom, V., 2020. Cherry picking with synthetic controls. Journal of Policy Analysis and Management 39, 510–532. doi:10. 1002/pam.22206.</li>
						<li>Kilian, L., Zhou, X., 2022. The impact of rising oil prices on US inflation and inflation expectations in 2020–23. Energy Economics 113, 106228. doi:10.1016/j.eneco.2022.106228.</li>
						<li></li>
					</ul>
				</section>

				<section class="chapter" data-transition="slide" data-background-color="rgb(35, 35, 35)">
					<h1>Appendix</h1>
				</section>

				<section>
					<img class="r-stretch" src="images/DAP.png">
				</section>

				<section>
					<img class="r-stretch" src="images/NRG.png">
				</section>

				<section>
					<img class="r-stretch" src="images/xNRG.png">
				</section>

				<section>
					<img class="r-stretch" src="images/CP00.png">
				</section>

				<section>
					<h2 class="slide-title">Synthetic controls</h2>
					<ul class="list-3">
						<li>Introduced by Abadie and Gardeazabal (2003),  Abadie et al. (2010)</li>
						<li class="fragment">Setup: One treated unit; several untreated units</li>
						<li class="fragment">Counterfactual is estimated as weighted average of untreated units → synthetic control unit</li>
						<li class="fragment">Similar units receive larger weights, vv</li>
					</ul>
				</section>

				<section>
					<h2 class="slide-title">Data and specifications</h2>
					<ul class="list-1">
						<li class="fragment">Control pool: 23 European countries</li>
						<li class="fragment">Portugal is removed to estimate effect for Spain, vv</li>
						<li class="fragment">Outcome variables: DAP, NRG, xNRG and CP00</li>
						<li class="fragment">All pre-treatment lags as predictors (Ferman et al., 2020)</li>
						<li class="fragment">June 2022 is removed from the analysis</li>
						<li class="fragment">Inference according to Chernozhukov et al. (2022)</li>
					</ul>
				</section>

				<section>
					<h2 class="slide-title-3">Synthetic controls (Abadie, 2021)</h2>
					<p class="fragment sc-bullet">We observe 
						<span>\((J+1) \in \mathbb{N}\)</span> 
						units over period 
						<span>\(T \in \mathbb{N}\)</span>
					</p>
					<p class="fragment sc-bullet">
						<span>\(J_{1}\)</span> 
						is assigned treatment at 
						<span>\(T_{0} \in (1, T)\)</span>
						; is treated over 
						<span>\(T_{1} = T-T_{0}\)</span> 
						periods
					</p>
					<p class="fragment sc-bullet">
						Our goal is to estimate 
						<span>\(\alpha_{1,t}=Y_{1,t}^{1}-Y_{1,t}^{0}\)</span>
						, for 
						<span>\(t \in \{T_{0}+1, ..., T\}\)</span>
					</p>
					<p class="fragment sc-bullet">
						Since 
						<span>\(Y_{1,t}^{1}\)</span> 
						is observable, we focus on 
						<span>\(Y_{1,t}^{0}\)</span> 
						to estimate 
						<span>\(\alpha_{1,t}\)</span>
					</p>
					<p class="fragment sc-bullet">
						Synthetic controls produce 
						<span>\(\widehat{Y}_{1,t}^{0}=\sum_{j=2}^{J+1} \widehat{w}_{j} Y_{j,t}\)</span> 
						for each 
						<span>\(t \in \{1,...,T\}\)</span>
					</p>
					<p class="fragment sc-bullet">
						<span>\(\mathbf{\widehat{W}(V)}\)</span> 
						is a vector of optimized weights assigned to each control unit
					</p>
					<p class="fragment sc-bullet">
						<span>\(\mathbf{\widehat{V}}\)</span> 
						is a vector of optimized weights assigned to each predictor
					</p>
				</section>

			</div>
		</div>
		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/math/math.js"></script>
		<script type="module">
		</script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ]
			});
		</script>
	</body>
</html>